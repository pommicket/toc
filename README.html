<h2>toc</h2>

<p><code>toc</code> is a language which compiles to C.</p>

<hr />

<h3>About</h3>

<p><code>toc</code> is currently in development. <strong>It is not a stable language,
and there are almost definitely bugs right now.</strong>
I would recommend against using it for anything big or important.
Many parts of it may change in the future.</p>

<p><code>toc</code> improves on C's syntax (and semantics) in many ways,
To declare <code>x</code> as an integer and set it to 5,
you can do:</p>

<p><code>
x := 5; // Declare x and set x to 5 (infer type) <br />
x : int = 5; // Explicitly make the type int. <br />
x : int; x = 5; // Declare x as an integer, then set it to 5.
</code></p>

<p><code>toc</code> is statically typed and has many of C's features, but
it is nearly as fast in theory.</p>

<p>See <code>docs</code> for more information (in progress).</p>

<p><code>tests</code> has some test programs written in <code>toc</code>.</p>

<p>To compile the compiler on a Unix-y system, just run <code>./build.sh release</code>. You can supply a compiler by running <code>CC=tcc ./build.sh release</code>, or build it in debug mode without the <code>release</code>. To disable compile time foreign function support (which you will need to do if you don't have ffcall/dl), prefix this with <code>COMPILE_TIME_FOREIGN_FN_SUPPORT=no</code>.</p>

<p>On other systems, you can just compile main.c with a C compiler. <code>toc</code> uses several C99 and a couple of C11 features, so it might not work on all compilers. But it does compile on quite a few, including <code>clang</code>, <code>gcc</code>, and <code>tcc</code>. It can also be compiled as if it were C++, so, MSVC and <code>g++</code> can also compile it (it does rely on implicit casting of  <code>void *</code> though). The <em>outputted</em> code should be C99-compliant.</p>

<h4>Why it compiles to C</h4>

<p><code>toc</code> compiles to C. Here are some reasons why:</p>

<ul>
<li>Speed. C is one of the most performant programming languages out there. It also has compilers which are very good at optimizing (better than anything I could write). </li>
<li>Portability. C is probably the most portable language. It has existed for >30 years and can run on practically anything. Furthermore, all major languages nowadays can call functions written in C.</li>
</ul>

<hr />

<h3><code>toc</code> Compiler Source Code</h3>

<p>Most of the source code for the <code>toc</code> compiler is licensed under the GNU General Public License, version 3, and the rest (some small general utilities) is in the public domain. Each source file begins with a comment explaining its license.</p>

<p>See <code>LICENSE</code> for the GNU General Public License.</p>

<p><code>toc</code> is written in C, for speed and portability. It has no dependencies, other than the C runtime library. If you want to be able to call external C functions at compile time, however, you will need <code>libffcall</code> and <code>libdl</code> (so this is only currently supported on Unix-y systems).</p>

<h4>Build system</h4>

<p><code>toc</code> is set up as a unity build, meaning that there is only one translation unit. So, <code>main.c</code> <code>#include</code>s <code>toc.c</code>, which <code>#include</code>s all of <code>toc</code>'s files.</p>

<h5>Why?</h5>

<p>This improves compilation speeds (especially from scratch), since you don't have to include headers a bunch of times for each translation unit. This is more of a problem in C++, where, for example, doing <code>#include &lt;map&gt;</code> ends up turning into 25,000 lines after preprocessing. All of toc's source code, which includes most of the C standard library, at the time of this writing (Dec 2019) is only 22,000 lines after preprocessing; imagine including all of that once for each translation unit which includes <code>map</code>. It also obviates the need for fancy build systems like CMake.</p>

<h4>New features</h4>

<p>Here are all the C99 features which <code>toc</code> depends on (I might have forgotten some...):</p>

<ul>
<li>Declare anywhere</li>
<li><code>inttypes.h</code></li>
<li>Non-constant struct literal initializers (e.g. <code>int x[2] = {y, z};</code>)</li>
<li>Flexible array members</li>
</ul>

<p>And here are all of its C11 features:</p>

<ul>
<li>Anonymous structures/unions</li>
<li><code>max_align_t</code> - It can still compile without this, and will almost definitely work, but it won't technically be standard-compliant</li>
</ul>

<h4>More</h4>

<p>See <code>main.c</code> for a bit more information.</p>

<hr />

<h3>Version history</h3>

<p>Here are the major versions of <code>toc</code>.</p>

<table>
<tr><th>Version</th><th>Description</th><th>Date</th></tr>
<tr><td>0.0</td><td>Initial version.</td><td>2019 Dec 6</td></tr>
<tr><td>0.1</td><td>Constant parameter inference.</td><td>2019 Dec 15</td></tr>
<tr><td>0.2</td><td>Foreign functions and #include.</td><td>2020 Jan 29</td></tr>
</table>

<hr />

<h3>Report a bug</h3>

<p>If you find a bug, you can report it through <a href="https://github.com/pommicket/toc/issues">GitHub's issue tracker</a>, or by emailing pommicket@gmail.com.</p>

<p>Just send me the <code>toc</code> source code which results in the bug, and I'll try to fix it. </p>
